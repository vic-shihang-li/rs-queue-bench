use crate::Arc;
use crate::ThreadPool;
use core::sync::atomic::{AtomicUsize, Ordering};

type BenchProcedure = fn() -> usize;

/// Repeatedly invokes a function that generates a number, for N times.
/// Returns the sum of every number generated by the procedure.
pub fn repeat_sum(ntimes: u32, procedure: BenchProcedure) -> usize {
    // use worker threads to do repeated benchmark runs
    let concurrent_test_thread_count = 5;
    let pool = ThreadPool::new(concurrent_test_thread_count);

    let sum = Arc::new(AtomicUsize::new(0));
    for _ in 0..ntimes {
        let sum_clone = sum.clone();
        pool.execute(move || {
            sum_clone.fetch_add(procedure(), Ordering::SeqCst);
        });
    }
    pool.join();

    sum.load(Ordering::SeqCst)
}

pub fn bench(name: &'static str, benchmark: BenchProcedure, num_trials: u32) {
    let sum = repeat_sum(num_trials, benchmark);
    let avg: f64 = (sum as f64) / (num_trials as f64);

    println!(
        "Bench '{name}': trials: {trials}; average (millis): {avg}",
        name = name,
        trials = num_trials,
        avg = avg
    );
}
